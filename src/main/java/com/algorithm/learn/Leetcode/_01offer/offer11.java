package com.algorithm.learn.Leetcode._01offer;

/**
 * 二进制中1的个数
 * * 题目链接
 *
 * https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
 * 题目
 *
 * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 */
public class offer11 {

    /**
     * 思路三
     *
     * 一个数和比自己小1的数做与运算，会把这个数最右边的1变成0；
     * 然后看能做几次这样的运算，这个数就有多少个1；
     * 这个方法有多少个1，就只需要循环多少次，是最优解法；
     * 如果一个整数不等于0，那么该整数的二进制表示中至少有一位是 1。先假设这个数的最右边一位是 1，那么减去 1 时，最后一位变成 0 而其他所有位都保持不变。也就是最后一位相当于做了取反操作，由 1 变成了 0。
     *
     * 接下来假设最后一位不是 1 而是 0 的情况。如果该整数的二进制表示中最右边 1 位于第 m 位，那么减去1时，第m 位由1 变成0，而第 m 位之后的所有 0 都变成 1整数中第 m 位之前的所有位都保持不变。举个例子，一个二进制数 1100，它的第二位是从最右边数起的一个 1。减去 1 后，第二位变成0，它后面的两位 0 变成 1，而前面的 1 保持不变，因此得到的结果是 1011。
     *
     * 在前面两种情况中, 我们发现把一个整数减去 1，都是把最右边的 1 变成0。如果它的右边还有 0 的话，所有的 0 都变成 1，而它左边所有位都保持不变。接下来我们把一个整数和它减去 1 的结果做位与运算，相当于把它最右边的 1 变成 0。还是以前面的 1100 为例，它减去 1 的结果是 1011。我们再把 1100和 1011 做位与运算，得到的结果是 1000。我们把 1100 最右边的 1 变成了0，结果刚好就是 1000。
     *
     * 总结: 把一个整数减去 1 再和原整数做与运算，会把该整数最右边一个 1 变成 0。那么一个整数的二进制表示中有多少个 1，就可以进行多少次这样的操作。
     *
     */

    public int NumberOf1(int n) {
        int count=0;
        while (n!=0){
            count++;
            n=n&(n-1);
        }
        return count;
    }
}
